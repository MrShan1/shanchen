# 调用函数
abs(100)       # 求绝对值的函数abs
cmp(1, 2)      # 比较函数cmp(x, y)
help(abs)
int('123')     # 类型转换函数
float('12.34')
str(1.23)
unicode(100)
bool('')
a = abs         # 变量a指向abs函数
a(-1)           # 所以也可以通过a调用abs函数




# 定义函数
def my_abs(x):
    if not isinstance(x, (int, float)):               # 如果有必要，可以先对参数的数据类型做检查
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x

import math
def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

x, y = move(100, 100, 60, math.pi / 6)     # 返回多个值
print x, y
r = move(100, 100, 60, math.pi / 6)        # 假象，Python函数返回的仍然是单一值tuple
print r





# 函数的参数
# 默认参数
def power(x, n=2):             # 默认参数，把第二个参数n的默认值设定为2
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
power(5)
power(5, 2)
power(5, 5)

def enroll(name, gender, age=6, city='Beijing'):
    print 'name:%s gender:%s age:%d city:%s' % (name, gender, age, city)
enroll('Sarah', 'F')
enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')

def add_end(L=[]):              # 默认参数很有用，但使用不当，也会掉坑里
    L.append('END')
    return L
add_end([1, 2, 3])
add_end(['x', 'y', 'z'])
add_end()
add_end()                        # 再次调用add_end()时，结果就不对了
def add_end(L=None):             # 可以用None这个不变对象来实现
    if L is None:                # 牢记一点：默认参数必须指向不变对象
        L = []
    L.append('END')
    return L

# 可变参数
def calc(*numbers):              # 给定一组数字a，b，c……，请计算a*a + b*b + c*c + ……
    sum = 0                      # 参数前面加了一个*号，函数内部接收的是一个tuple
    for n in numbers:
        sum = sum + n * n
    return sum
calc(1, 2)
calc()
nums = [1, 2, 3]
calc(nums[0], nums[1], nums[2])
calc(*nums)                       # 在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去

# 关键字参数
def person(name, age, **kw):      # **kw是关键字参数，kw接收的是一个dict
    print 'name:', name, 'age:', age, 'other:', kw
person('Michael', 30)
person('Bob', 35, city='Beijing')
person('Adam', 45, gender='M', job='Engineer')
kw = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=kw['city'], job=kw['job'])
person('Jack', 24, **kw)

# 参数组合
def func(a, b, c=0, *args, **kw):
    print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw
func(1, 2)
func(1, 2, c=3)
func(1, 2, 3, 'a', 'b')
func(1, 2, 3, 'a', 'b', x=99)
args = (1, 2, 3, 4)
kw = {'x': 99}
func(*args, **kw)             # 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的

# 递归函数
def fact(n):                  # 计算阶乘n! = 1 x 2 x 3 x ... x n
    if n==1:
        return 1
    return n * fact(n - 1)
fact(5)
fact(100)
fact(1000)                     # 使用递归函数需要注意防止栈溢出

def fact(n):                   # 解决递归调用栈溢出的方法是通过尾递归优化
    return fact_iter(n, 1)     # 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
                               # 大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，
@tail_call_optimized           # 所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)

# 作者用了抛出异常然后自己捕获的方式来打破调用栈的增长，性能无法保证，只实现尾调用不爆栈
import sys    
class TailRecurseException:  
   def __init__(self, args, kwargs):  
     self.args = args  
     self.kwargs = kwargs  

def tail_call_optimized(g):   
   def func(*args, **kwargs):  
     f = sys._getframe()  
     if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code:  
       raise TailRecurseException(args, kwargs)  
     else:  
       while 1:  
         try:  
           return g(*args, **kwargs)  
         except TailRecurseException, e:  
           args = e.args  
           kwargs = e.kwargs  
   func.__doc__ = g.__doc__  
   return func


import types
def fact_iter(num, product):
    if num == 1:
        yield product
    yield fact_iter(num - 1, num * product)
def tramp(gen, *args, **kwargs):
    g = gen(*args, **kwargs)
    while isinstance(g, types.GeneratorType):
        g=g.next()
    return g
print tramp(fact_iter, 1000，1)