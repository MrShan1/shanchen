# 切片
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
[L[0], L[1], L[2]]  # 取前3个元素
r = []
n = 3
for i in range(n):  # 取前N个元素
     r.append(L[i])
 
r
L[0:3]    # 取前3个元素
L[:3]     # 如果第一个索引是0，可以省略
L[1:3]    # 从索引1开始，取出2个元素
L[-2:]    # 取最后2个元素
L[-2:-1]  # 取倒数第二个元素
# 原型[start:stop:step]
# 开始索引：默认0。索引自左至右从0开始，自右至左从-1开始
# 结束索引：默认len(li)。取到该索引为止，不包含该索引的值
# 步长值：默认1。若3隔2取1。非0，+从左向右取，-从右向左取
L = range(100)  # 创建一个0-99的数列
L[:10]          # 前10个数
L[-10:]         # 后10个数
L[10:20]        # 前11-20个数
L[:10:2]        # 前10个数，每两个取一个
L[::5]          # 所有数，每5个取一个
L[:]            # 原样复制一个list
L[150:]         # 不报异常
t = (0, 1, 2, 3, 4, 5)  # tuple也可以用切片操作
t[:3]                   # 操作的结果仍是tuple
s = 'ABCDEFG'           # 字符串也可以用切片操作
s[::2]                  # 操作结果仍是字符串




# 迭代
d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    # 只要是可迭代对象，无论有无下标，都可以迭代
    print key
for ch in 'ABC':
    print ch
from collections import Iterable # 通过collections模块的Iterable类型判断
isinstance('abc', Iterable)      # str是否可迭代
isinstance([1,2,3], Iterable)    # list是否可迭代
isinstance(123, Iterable)        # 整数是否可迭代
for i, value in enumerate(['A', 'B', 'C']):
    # 内置的enumerate函数可以把一个list变成索引-元素对
    # 实现类似Java那样的下标循环
    print i, value
for x, y, z in [(1, 1, 1), (2, 4, 16), (3, 9, 81)]:
    # for循环里，同时引用了多个变量
    print x, y, z



# 列表生成式
# range(1, 11)  # 生成list [1, 2, 3, ..., 9, 10]
L = []          # 生成list [1x1, 2x2, 3x3, ..., 10x10]
for x in range(1, 11):
    L.append(x * x)
[x * x for x in range(1, 11)]
[x * x for x in range(1, 11) if x % 2 == 0]  # 筛选出仅偶数的平方
[m + n for m in 'ABC' for n in 'XYZ']        # 使用两层循环，生成全排列
d = {'x': 'A', 'y': 'B', 'z': 'C' }
[k + '=' + v for k, v in d.iteritems()]      # 使用多个变量来生成list
L = ['Hello', 'World', 18, 'Apple', None]
{i: v for i, v in enumerate(L)}              # 使用多个变量来生成dict
[s.lower() if isinstance(s, str) else s for s in L]  # 大小写转换




# 生成器
# 一边循环一边计算的机制，称为生成器（Generator），generator保存的是算法
g = (x * x for x in range(10))  #　第一种创建方法，把一个列表生成式的[]改成()
g.next()
g = (x * x for x in range(10))
for n in g:
    # 创建了一个generator后，一般不会调用next()方法，而是通过for循环来迭代它
     print n,
def fib(max):
    # 斐波拉契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, ...
    n, a, b = 0, 0, 1
    while n < max:
        # 第二种创建方法，函数定义中包含yield关键字
        yield b
        a, b = b, a + b
        n = n + 1
for n in fib(10):
    print n,
def odd():
    # 变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回
    # 再次执行时从上次返回的yield语句处继续执行
    print 'step 1'
    yield 1
    print 'step 2'
    yield 3
    print 'step 3'
    yield 5
o = odd()
o.next()